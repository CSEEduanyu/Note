1. 赋值操作符

2. 单例模式

3. 二维数组查找：递归，从右上角开始的数A开始；
	- 如果目标>A，则查找A左边的数；
	- 目标< A，则查找A右边的数；
	- 目标==A，返回。

4. 替换空格：时间复杂度O(n)
	- 遍历一遍计算出所有的空格数，和替换后的字符串长度。
	- p1指向原字符串尾部,p2指向替换后的字符串尾部。从尾部开始复制。

5. 从尾到头打印链表：用栈结构。如果用递归，函数栈的大小可能不够。

6. **重建二叉树**（通过前序遍历和中序遍历重建一棵二叉树）
	- 前序遍历序列第一个值是根，接着是左子树的所有节点，再是右子树的所有节点。中序遍历序列根在中间，左子树所有节点在根的左边，右子树所有节点在右边。
	- 递归重建。

7. 两个栈实现队列
	- 进队列的元素都放进stack1
	- 当有元素要出队列
		- 当stack2为空，将stack1中的元素都压入stack2（实现了顺序反转）,再弹出stack2栈顶的元素。
		- stack2不为空，弹出stack2栈顶的元素。

8. **旋转数组的最小元素**（两个递增数组，第一个中元素大于第二个）：O(logn)
	- p1指向第一个数，p2指向最后一个数
	- 特例：*p1小于*p2，返回。
	- 循环，mid = (p1+p2)/2，如果大于*p1，则p1=mid;否则拍=mid。
	- 最后p1=p2+1,返回*p2

9. 斐波那契数列：动态规划

10. 二进制中1的个数：把一个整数减去1，再和原数做“与运算”，会把该整数最右边的一个1置0；循环到整数变成0；

11. 数值的整数次方:O(logn)时间复杂度，注意负指数。

12. 打印1到最大的n位数
	- 注意大数问题，用数组表示n位数。
	- 递归全排列。

13. **O(1)时间删除链表结点**（只给链表头结点和要删除的结点p）
	- 将p的下一个结点q，复制到p。删除q。

14. **调整数组顺序使奇数在偶数前**
	- p1指向第一个数，只向后移动。p2指向最后，只向前移动。当p1指向偶数，p2指向奇数就交换。
	- 函数模板，将是否是偶数用函数指针传递进去。

15. 链表倒数第k个结点：两个指针，第一个先走k步

16. 反转链表：三个连续的节点，移动

17. 合并两个排序的链表：比较两个链表的头部

18. 树的子结构：
	- 第一步查A中是否有B的根节点的值，假如有设为R。
	- 第二步查R为根结点的子树和B的子树是否相同。

19. 二叉树的镜像：递归

20. 顺时针打印矩阵：小心边界条件

21. 包含min函数的栈：用一个辅助栈储存min值

22. **判断两个序列是否是栈的压入和弹出序列**
	- 建立辅助栈，过一遍弹出序列
	- 如果下一个弹出的数字刚好是栈顶的数字，那么直接弹出。
	- 否则将压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。
	- 如果所有的数字都入栈，还没有找到下一个弹出的数字，那说明序列不可能是弹出序列。

23. 层序打印二叉树：队列

24. 判断序列是否是二叉搜索树的后序遍历：根节点在最后，前面子树节点必须小于根节点，后面必须大于根结点。递归。

25. 二叉树求所有这样的路径，路径上结点的和为某一值。：回溯

26. 复杂链表的复制：每个结点后都增加的复制结点；pRand指针指向原结点pRand指针指向的后一个；再将链表一分为二。

27. **二叉搜索树转换成排序的双向链表**（不能创建新结点）：中序遍历，用一个```Node**```记录排序链表的尾结点。递归。

28. 打印字符串的全排列：将字符串分成第一个字符，和剩下所有的字符。交换第一个字符和剩下的。递归。

29. 求数组中出现次数操作一半的数字：O(n)
	- 遍历数组。保存一个数字和一个值times。如果下一个数字相同则times+1，否则times-1。
	- 最后将val置为1的一定是出现次数超过一半的。
	- 最后要检测这个数是不是真的超过一半。

30. 数组中最小的K个数：
	- O(nlogk)：适合海量数据。维护一个大小为k最大堆。
	- O(n)：能修改数组，用partition（），使得比第k个数小的所有数字都位于数组左边。

31. 子树组的最大和：O(n),遍历数组，如果前i-1个元素的和小于1，和直接为data[i]

32. 从1到n整数中1出现的次数：
	- 直观方法对10求余，判断余数是不是1。O(nlogn)
	- 数字规律

33. **数组排成最小数**
	- 大数问题将数字转字符串。定义一个两字符串连接后的,排序方法cmp{a+b< b+a}；然后调用sort();

34. 丑数（只含有2\3\5因子的数，1也是丑数），求第k个。
	- 记录三个位置T2,T3,T5;每次求min(T2*2,T3*3,T5*5)得到新的丑数，然后更新T2,T3,T5。

35. 第一个只出现一次的字符：长为256的vector

36. **数组中的逆序对**
	- hint:逆序对只与两个数的前后顺序有关，不在乎前后间隔大小。
	- 采用类似归并的做法，当合并两个已排序的子序列a,b(a在前，b在后)。用两个指针pa、pb分别指向a、b的末尾。每次比较两个指针指向的数字大小。如果pa大于pb,那么增加逆序对的个数等于b的剩余数个数。

37. 两个链表的第一个公共节点
	- Y字形。单向链表，两个链表头都走一遍。记录长度，然后长的先走。

38. 数字在排序数组中出现的次数：二分查找。

39. 二叉树的深度：递归
	- 求二叉树是否平衡，后序遍历求出左右子树的深度，记录下来。

40. 数组中数字除了两个数字以外，都出现过两次。求只出现一次的数字，时间复杂度O(n),空间复杂度O(1)。
	- 所有数字异或，就得到那两个数字的异或结果。我们在结果中找到第一个为1的位。说明这两个数字在这个位上不一样。以这个为区别，把整个数组分为两个子数组。分别异或。

41. 和为S的两个数字 VS 和为S的连续正数序列
	- hint:在前移次操作的基础上，求后一次操作的和
	- 第一题 two points
	- 第二题 two points：一开始small指向1，big指向2。如果small到big的和大于s,small+1;如果小于s,big。终止条件是small=S+1/2;

42. 翻转单词顺序 VS 左旋转字符串
	- 两次翻转：先翻整个，再翻部分

43. n个骰子的所有可能点数的概率
	- 动归。n个骰子甩出a点的可能方式等于，dp[n，a] = dp[n-1,a-1]+ dp[n]

44. 