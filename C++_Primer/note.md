#C++语法细节

######理解变量类型
* 例如
```cpp
int *p， q;   //p是int型指针，q是int
int *&r = p;  //r是对指针p的引用
int (*a)[n];  //数组指针：指向int数组的指针
int   *a[n]； //指针数组：[ ]的优先级高，a是一个数组，存放int*类型元素。
```
* 类型修饰符(*或&)仅仅修饰单个变量
* 从右向左阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响。

######类型转换
* 无符号类型注意不能赋值成负数。否则值实际为对这个负数取模。
* 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。
* 显式类型转换cast
	* static_cast:处理具有明确定义的类型转换，不包含底层const。，这种强制转换只会在编译时检查。 如果编译器检测到您尝试强制转换完全不兼容的类型，则static_cast会返回错误。
	* reinterpret:处理非关联的类型转换，通过改变对象的位模式。例如 pointer 和 int的无关类型的转换。
	* const_cast:只能改变运算对象的底层const,
	* dynamic_cast：在运行时检查基类指针和派生类指针之间的强制转换。


___




######作用域嵌套
* 内层作用域可以重定义外层作用域已有的名字。
* 但可以通过作用域操作符来访问外层变量。::是**作用域操作符**。全局作用域没有名字，所以::name是特指全局作用域里的name变量。

######声明、定义、初始化
* 变量能且只能被定义一次，但是可以被声明多次。
```cpp
extern int i;			//声明i
int j;       			//声明并定义j
extern double pi=3.1416;//定义并初始化
```
___
####const限定符
* const对象一旦创建后其值就不能改变，所以const对象必须初始化
* 默认情况下const对象仅在文件内有效，不同文件需要定义同名的const变量，它们是独立的。
* 如果想只在一个文件内定义，可以使用extern关键字。
```cpp
//文件1中定义，该常量能被其他文件访问
extern cnost int bufSize = fcn();
//文件2中的声明，与文件1中是同一个
extern const int bufSize;
```

######const与引用
* 对const的引用，简称常量引用，即把引用绑定到const对象上。**底层const**。
* 想要引用常量必须使用常量引用，但常量引用可以引用非常量对象。
* 允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式。而一半引用是不可以的。

######const与指针
* 指向常量的指针：想要存放常量对象的地址，只能使用指向常量的指针。**底层const**。
* const指针：指针本身是const，即指针初始化后的值（那个地址）不能改变。**顶层const**。

**在拷贝操作时，拷入和拷出的变量必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。
一般来说，非常量可以转换成常量，反之则不行**



