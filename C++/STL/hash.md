#####解决堆积问题
* 开放定址法（装填因子< 0.5）
	* 线性探测：步长为i探测。从冲突位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中。 堆积问题：这样容易形成一块连续区域被占用，那散列到这一块区域的key值都会冲突。
	
	* 平方探测：i^2探测。依次寻找向后第1个，第4个，第9个。 二次聚集问题：即冲突后探测相同的备选单。

	* 双散列：步长为hash2(X)。以另一个哈希函数的结果作为步长。

	* 伪随机探测再散列：通过一个伪随机数发生器 给定一个随机数作为步长查找。

* 再散列：装填因子已经比较大的情况下，使用一个相关的新hash函数，建立一个大约两倍的大的表。

* 分离链接法：以地址为i的元素为例，当有同样的地址的元素出现时就构造一个以i为同义词的单链表，即就是将相同地址的元素链接成一个单链表然后将该单链表挂接在以i为存储单元的哈希表中。

* 建立公共溢出区：将基本表和溢出表分开，只要产生导致冲突的元素就直接存放到溢出表中。




#####hash构造方法

   1. 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数）

　　2. 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
　　
　　3. 平方取中法：取关键字平方后的中间几位作为散列地址。
　　
　　4. 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。
　　
　　5. 随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。
　　
　　6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。